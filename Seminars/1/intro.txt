Как создавать процессы?


int fork();

-->
pid = fork();
if (pid < 0)
	error();
else if (pid == 0)
	child();
else
	parent();


Отличить родителя от ребенка можно по коду возврата функции fork(). Относительные точки входа в обоих процессах при возврате функции fork() будут одними и теми же.

Как узнать собственный идентификатор процесса?

int detpid() 	- возвращает собственный идентификатор
int getppid()	- возвращает идентификатор родителя
sub
#ps -axf  печатает список всех процессов (a - все, x - ,f - в виде дерева)


int wait(int* status);	-- ждет пока выполнится дочерний процесс 
							status - адрес, куда будет положен код возврата
							возвращает идентификатор завершившегося процесса

Поток отличается от процесса лишь тем, что первый работает в едином адресном пространстве с родителем.

int pthread_create(	pthread_t* tid,
					pthread_attr_t* attr /*can be NULL*/,
					void (*routine)(void*),
					void* arg /*to the argumented function*/
				   )

Умеем порождать процессы и нити. Как подгружать исполняемый файл? В рамках нового процесса сменить исполняемый файл, который исполняется. Так работает shell.

execl, execle, execlp, execv, execvp, execvl

#ps -axf

exec..("ps", "ps", "-axf")
			|-------------|
				 argv
argv[0] СОВПАДАЕТ С ПРОГРАММОЙ

Если передаем массивом, то маркером конца массива является NULL.

getenv() 

Нужно написать ./a.out ps -axf, чтобы работало :)

